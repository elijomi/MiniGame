@page "/solitaire"
@using System.Text.Json

<PageTitle>Solitaire</PageTitle>

<div class="sol-wrapper">
    <div class="game-header">
        <h1>Solitaire</h1>
        <div class="counters">
            <span><strong>Moves:</strong> @moves</span>
            <span><strong>Redeals:</strong> @redeals</span>
        </div>
        <div class="actions">
            <button class="btn btn-sm btn-secondary" @onclick="NewGame">New Game</button>
            <button class="btn btn-sm btn-secondary" @onclick="Undo" disabled="@(!CanUndo)">Undo</button>
        </div>
    </div>

    <div class="board">
        <div class="top-row">
            <!-- Foundations leftmost (4) -->
            @for (var f = 0; f < 4; f++)
            {
                var ff = f; // capture per-iteration index
                <div class="pile foundation"
                     @onclick="(() => OnClickFoundation(ff))">
                @foreach (var (card, i) in EnumeratePile(foundations[ff]))
                {
                    var ii = i; // capture per-iteration index
                    <div class="sol-card @(card.FaceUp ? "faceup" : "facedown") @(IsSelected(DragSourceKind.Foundation, ff, ii) ? " selected" : string.Empty)"
                         style="top:@(ii * 1)px; left:@(ii * 0)px;">
                         @CardInner(card)
                     </div>
                }
                    @if (foundations[ff].Count == 0)
                    {
                        <div class="slot" @onclick="(() => OnClickFoundation(ff))"></div>
                    }
                </div>
            }

            <div class="spacer"></div>

            <!-- Waste then Stock (rightmost) -->
            <div class="pile waste"
                 @onclick="OnClickWaste"
                 @ondblclick="OnDoubleClickWaste">
                @{ var start = Math.Max(0, waste.Count - 3); }
                @for (var i = start; i < waste.Count; i++)
                {
                    var card = waste[i];
                    var ii = i; var isTop = ii == waste.Count - 1;
                    // Fan to the left so waste never intrudes into the stock pile
                    var relRight = (waste.Count - 1) - i; // 0 for rightmost (top), then 1,2 for previous
                    <div class="sol-card @(card.FaceUp ? "faceup" : "facedown") @(IsSelected(DragSourceKind.Waste, 0, ii) ? " selected" : string.Empty)"
                         style="left:@(-(relRight * 16))px;">
                         @CardInner(card)
                     </div>
                }
                @if (waste.Count == 0)
                {
                    <div class="slot" @onclick="OnClickWaste"></div>
                }
            </div>

            <div class="pile stock" @onclick="DrawFromStock">
                @if (stock.Count == 0)
                {
                    <div class="slot empty-stock" title="Redeal from waste"></div>
                }
                else
                {
                    <div class="sol-card facedown"></div>
                }
            </div>
        </div>

        <div class="tableau-row">
            @for (var t = 0; t < 7; t++)
            {
                var tt = t; // capture per-iteration index
                <div class="pile tableau"
                     @onclick="(() => OnClickTableau(tt))">
                    @for (var i = 0; i < tableau[tt].Count; i++)
                    {
                        var ii = i; // capture per-iteration index
                        var card = tableau[tt][ii];
                        var offset = card.FaceUp ? FaceUpTableauOffset : FaceDownTableauOffset;
                        var top = ii * offset;
                        var isDraggable = card.FaceUp; // allow dragging runs starting at any face-up card
                        <div class="sol-card @(card.FaceUp ? "faceup" : "facedown") @(IsSelected(DragSourceKind.Tableau, tt, ii) ? " selected" : string.Empty)"
                             style="top:@($"{top}px");"
                             @onclick="(() => OnClickTableauCard(tt, ii))" @onclick:stopPropagation="true"
                             @ondblclick="(() => OnDoubleClickTableauCard(tt, ii))" @ondblclick:stopPropagation="true">
                             @CardInner(card)
                         </div>
                    }
                    @if (tableau[tt].Count == 0)
                    {
                        <div class="slot" @onclick="(() => OnClickTableau(tt))"></div>
                    }
                </div>
            }
        </div>
    </div>
</div>

@code {
    private enum Suit { Clubs, Diamonds, Hearts, Spades }
    private enum DragSourceKind { Tableau, Waste, Foundation }

    private readonly record struct Card(Suit Suit, int Rank, bool FaceUp)
    {
        public bool IsRed => Suit is Suit.Hearts or Suit.Diamonds;
    }

    private readonly List<Card> stock = new();
    private readonly List<Card> waste = new();
    private readonly List<Card>[] foundations = new List<Card>[4]
    {
        new(), new(), new(), new()
    };
    private readonly List<Card>[] tableau = new List<Card>[7]
    {
        new(), new(), new(), new(), new(), new(), new()
    };

    private int moves = 0;
    private int redeals = 0; // unlimited, tracked
    private const int FaceUpTableauOffset = 34;
    private const int FaceDownTableauOffset = 14;

    private readonly record struct DragPayload(DragSourceKind Kind, int Index, int StartIndex);
    private DragPayload? selected; // click-to-move selection

    private readonly Random rng = new();

    protected override void OnInitialized()
    {
        NewGame();
    }

    private void NewGame()
    {
        moves = 0;
        redeals = 0;
        stock.Clear(); waste.Clear();
        foreach (var f in foundations) f.Clear();
        foreach (var t in tableau) t.Clear();

        // build and shuffle deck
        var deck = new List<Card>(52);
        foreach (Suit s in Enum.GetValues(typeof(Suit)))
            for (int r = 1; r <= 13; r++) deck.Add(new Card(s, r, false));

        for (int i = deck.Count - 1; i > 0; i--)
        {
            int j = rng.Next(i + 1);
            (deck[i], deck[j]) = (deck[j], deck[i]);
        }

        // deal tableau 1..7 columns
        int cursor = 0;
        for (int col = 0; col < 7; col++)
        {
            for (int i = 0; i <= col; i++)
            {
                var faceUp = (i == col);
                var c = deck[cursor++];
                tableau[col].Add(c with { FaceUp = faceUp });
            }
        }

        // rest to stock
        for (; cursor < deck.Count; cursor++) stock.Add(deck[cursor]);
    }

    private bool CanUndo => undoStack.Count > 0;
    private readonly Stack<GameSnapshot> undoStack = new();
    private readonly record struct GameSnapshot(
        Card[] Stock, Card[] Waste,
        Card[][] Foundations, Card[][] Tableau,
        int Moves, int Redeals
    );

    private void PushUndo()
    {
        undoStack.Push(new GameSnapshot(
            stock.ToArray(),
            waste.ToArray(),
            foundations.Select(p => p.ToArray()).ToArray(),
            tableau.Select(p => p.ToArray()).ToArray(),
            moves, redeals
        ));
    }

    private void Undo()
    {
        if (!CanUndo) return;
        var s = undoStack.Pop();
        stock.Clear(); stock.AddRange(s.Stock);
        waste.Clear(); waste.AddRange(s.Waste);
        for (int i = 0; i < 4; i++) { foundations[i].Clear(); foundations[i].AddRange(s.Foundations[i]); }
        for (int i = 0; i < 7; i++) { tableau[i].Clear(); tableau[i].AddRange(s.Tableau[i]); }
        moves = s.Moves + 1; // undo counts as a move
        redeals = s.Redeals;
    }

    private void DrawFromStock()
    {
        PushUndo();
        if (stock.Count > 0)
        {
            var c = stock[^1]; stock.RemoveAt(stock.Count - 1);
            waste.Add(c with { FaceUp = true });
            moves++;
        }
        else if (waste.Count > 0)
        {
            // redeal: move waste back to stock face-down, preserving order reversed
            for (int i = waste.Count - 1; i >= 0; i--)
            {
                var c = waste[i];
                stock.Add(c with { FaceUp = false });
            }
            waste.Clear();
            redeals++; moves++;
        }
        // Clear any selection after drawing or redealing
        selected = null;
    }

    private void OnClickWaste()
    {
        if (waste.Count == 0) return;
        var topIdx = waste.Count - 1;
        if (selected is DragPayload s && s.Kind == DragSourceKind.Waste && s.Index == 0 && s.StartIndex == topIdx)
        {
            // Toggle off if clicking the already-selected waste card
            selected = null;
            return;
        }
        selected = new DragPayload(DragSourceKind.Waste, 0, topIdx);
    }

    private void OnClickFoundation(int f)
    {
        if (selected is DragPayload s)
        {
            switch (s.Kind)
            {
                case DragSourceKind.Waste:
                {
                    if (waste.Count == 0) break;
                    var card = waste[^1];
                    LogAttemptToFoundation(card, f);
                    TryMoveSingleToFoundation(card, () => { waste.RemoveAt(waste.Count - 1); return true; }, f);
                    break;
                }
                case DragSourceKind.Tableau:
                {
                    var t = s.Index;
                    var topIdx = FindTopFaceUpIndex(t);
                    if (topIdx < 0) break;
                    var card = tableau[t][topIdx];
                    LogAttemptToFoundation(card, f);
                    TryMoveSingleToFoundation(card, () => { tableau[t].RemoveAt(topIdx); AutoFlipTop(t); return true; }, f);
                    break;
                }
            }
            selected = null;
        }
        else
        {
            if (foundations[f].Count > 0)
                selected = new DragPayload(DragSourceKind.Foundation, f, foundations[f].Count - 1);
        }
    }

    private void OnClickTableau(int t)
    {
        if (selected is DragPayload s)
        {
            switch (s.Kind)
            {
                case DragSourceKind.Waste:
                {
                    if (waste.Count == 0) break;
                    var card = waste[^1];
                    LogAttemptToTableau(card, t);
                    if (CanPlaceOnTableau(card, t))
                    {
                        PushUndo();
                        waste.RemoveAt(waste.Count - 1);
                        tableau[t].Add(card);
                        moves++;
                    }
                    break;
                }
                case DragSourceKind.Tableau:
                {
                    var from = s.Index; var start = s.StartIndex;
                    if (from == t) break;
                    var run = tableau[from].Skip(start).ToList();
                    if (run.Count == 0 || !run[0].FaceUp) break;
                    {
                        var placeOk = CanPlaceOnTableau(run[0], t);
                        var runOk = IsValidRun(run);
                        LogAttemptToTableau(run[0], t, placeOk && runOk);
                    }
                    if (CanPlaceOnTableau(run[0], t) && IsValidRun(run))
                    {
                        PushUndo();
                        tableau[from].RemoveRange(start, tableau[from].Count - start);
                        tableau[t].AddRange(run);
                        AutoFlipTop(from);
                        moves++;
                    }
                    break;
                }
                case DragSourceKind.Foundation:
                {
                    var f = s.Index;
                    if (foundations[f].Count == 0) break;
                    var card = foundations[f][^1];
                    LogAttemptToTableau(card, t);
                    if (CanPlaceOnTableau(card, t))
                    {
                        PushUndo();
                        foundations[f].RemoveAt(foundations[f].Count - 1);
                        tableau[t].Add(card);
                        moves++;
                    }
                    break;
                }
            }
            selected = null;
        }
        else
        {
            // Select the topmost face-up card in the pile (start of run)
            var i = FindTopFaceUpIndex(t);
            if (i >= 0) selected = new DragPayload(DragSourceKind.Tableau, t, i);
        }
    }

    // Handle clicks on individual tableau cards to allow selecting any face-up card
    private void OnClickTableauCard(int t, int i)
    {
        // If there's an active selection from another pile, treat this as a drop onto pile t
        if (selected is DragPayload s)
        {
            // If selection is not from this same tableau pile, attempt the move to this pile
            if (s.Kind != DragSourceKind.Tableau || s.Index != t)
            {
                OnClickTableau(t);
                return;
            }

            // Selection is from this same pile: update the run start to the clicked face-up card
            if (i >= 0 && i < tableau[t].Count && tableau[t][i].FaceUp)
            {
                // Toggle off if re-clicking the same selected card
                if (s.StartIndex == i)
                {
                    selected = null;
                }
                else
                {
                    selected = new DragPayload(DragSourceKind.Tableau, t, i);
                }
            }
            return;
        }

        // No selection yet: select clicked card if it's face-up
        if (i >= 0 && i < tableau[t].Count && tableau[t][i].FaceUp)
        {
            selected = new DragPayload(DragSourceKind.Tableau, t, i);
        }
    }

    // Double-click: attempt to auto-move the top face-up card to its foundation
    private void OnDoubleClickTableauCard(int t, int i)
    {
        if (t < 0 || t >= tableau.Length) return;
        if (tableau[t].Count == 0) return;
        var topIndex = tableau[t].Count - 1;
        if (i != topIndex) return; // Only allow topmost card to auto-move
        var card = tableau[t][topIndex];
        if (!card.FaceUp) return;

        var f = FindFoundationIndexFor(card);
        if (f is int fi)
        {
            LogAttemptToFoundation(card, fi);
            TryMoveSingleToFoundation(card, () => { tableau[t].RemoveAt(topIndex); AutoFlipTop(t); return true; }, fi);
            selected = null; // clear any selection that might have been started by single-click
        }
    }

    private int FindTopFaceUpIndex(int t)
    {
        for (int i = tableau[t].Count - 1; i >= 0; i--)
        {
            if (tableau[t][i].FaceUp) return i;
        }
        return -1;
    }

    private int? FindFoundationIndexFor(Card card)
    {
        // Prefer an existing pile with the same suit if possible
        for (int f = 0; f < 4; f++)
        {
            if (foundations[f].Count > 0 && foundations[f][^1].Suit == card.Suit && CanPlaceOnFoundation(card, f))
                return f;
        }
        // Otherwise, any pile that legally accepts (e.g., Ace to empty)
        for (int f = 0; f < 4; f++)
        {
            if (CanPlaceOnFoundation(card, f)) return f;
        }
        return null;
    }

    // Double-click top waste card to auto-move to a foundation if legal
    private void OnDoubleClickWaste()
    {
        if (waste.Count == 0) return;
        var card = waste[^1];
        var f = FindFoundationIndexFor(card);
        if (f is int fi)
        {
            LogAttemptToFoundation(card, fi);
            TryMoveSingleToFoundation(card, () => { waste.RemoveAt(waste.Count - 1); return true; }, fi);
            selected = null;
        }
    }

    private string CardLabel(Card c) => $"{RankToText(c.Rank)}{SuitToUtf16(c.Suit)}";

    private void LogAttemptToTableau(Card moving, int t, bool? legalOverride = null)
    {
        var pile = tableau[t];
        var target = pile.Count == 0 ? "empty" : CardLabel(pile[^1]);
        var legal = legalOverride ?? CanPlaceOnTableau(moving, t);
        Console.WriteLine($"Attempt: {CardLabel(moving)} -> {target}: {(legal ? "Legal" : "Illegal")}");
    }

    private void LogAttemptToFoundation(Card moving, int f)
    {
        var pile = foundations[f];
        var target = pile.Count == 0 ? "empty" : CardLabel(pile[^1]);
        var legal = CanPlaceOnFoundation(moving, f);
        Console.WriteLine($"Attempt: {CardLabel(moving)} -> {target}: {(legal ? "Legal" : "Illegal")}");
    }

    private void TryMoveSingleToFoundation(Card card, Func<bool> removeFromSource, int foundationIndex)
    {
        if (CanPlaceOnFoundation(card, foundationIndex))
        {
            PushUndo();
            removeFromSource();
            foundations[foundationIndex].Add(card);
            moves++;
        }
    }

    private bool CanPlaceOnFoundation(Card card, int f)
    {
        var pile = foundations[f];
        if (pile.Count == 0) return card.Rank == 1; // Ace
        var top = pile[^1];
        return card.Suit == top.Suit && card.Rank == top.Rank + 1;
    }

    private bool CanPlaceOnTableau(Card card, int t)
    {
        var pile = tableau[t];
        if (pile.Count == 0) return card.Rank == 13; // King on empty
        var top = pile[^1];
        if (!top.FaceUp) return false;
        return (card.IsRed != top.IsRed) && (card.Rank == top.Rank - 1);
    }

    private static bool IsValidRun(List<Card> run)
    {
        for (int i = 0; i < run.Count - 1; i++)
        {
            var a = run[i]; var b = run[i + 1];
            if (!b.FaceUp) return false;
            if ((a.IsRed == b.IsRed) || (a.Rank != b.Rank + 1)) return false;
        }
        return true;
    }

    private void AutoFlipTop(int t)
    {
        if (tableau[t].Count == 0) return;
        var top = tableau[t][^1];
        if (!top.FaceUp)
        {
            tableau[t][^1] = top with { FaceUp = true };
        }
    }

    private static IEnumerable<(Card card, int index)> EnumeratePile(List<Card> pile)
    {
        for (int i = 0; i < pile.Count; i++) yield return (pile[i], i);
    }

    private RenderFragment CardInner(Card c) => builder =>
    {
        // Face-down card uses CSS only
        if (!c.FaceUp) return;
        var seq = 0;
        builder.OpenElement(seq++, "div");
        builder.AddAttribute(seq++, "class", "card-face");

        // Rank/Suit glyphs
        builder.OpenElement(seq++, "div"); builder.AddAttribute(seq++, "class", $"corner sol-tl {(c.IsRed ? "sol-red" : "sol-black")}");
        builder.AddContent(seq++, RankToText(c.Rank)); builder.AddMarkupContent(seq++, "<br/>"); builder.AddContent(seq++, SuitToUtf16(c.Suit)); builder.CloseElement();
        builder.OpenElement(seq++, "div"); builder.AddAttribute(seq++, "class", $"corner sol-br {(c.IsRed ? "sol-red" : "sol-black")}");
        builder.AddContent(seq++, RankToText(c.Rank)); builder.AddMarkupContent(seq++, "<br/>"); builder.AddContent(seq++, SuitToUtf16(c.Suit)); builder.CloseElement();

        builder.CloseElement();
    };

    private static string RankToText(int r) => r switch
    {
        1 => "A", 11 => "J", 12 => "Q", 13 => "K", _ => r.ToString()
    };

    private static string SuitToGlyph(Suit s) => s switch
    {
        Suit.Clubs => "♣",
        Suit.Diamonds => "♦",
        Suit.Hearts => "♥",
        Suit.Spades => "♠",
        _ => "?"
    };

    private bool IsSelected(DragSourceKind kind, int index, int cardIndex)
        => selected is DragPayload s && s.Kind == kind && s.Index == index && s.StartIndex == cardIndex;
    
    private static string SuitToUtf16(Suit s)
    {
        return s switch
        {
            Suit.Clubs => ((char)0x2663).ToString(),
            Suit.Diamonds => ((char)0x2666).ToString(),
            Suit.Hearts => ((char)0x2665).ToString(),
            Suit.Spades => ((char)0x2660).ToString(),
            _ => "?"
        };
    }
}
