@page "/snake"
@implements IDisposable

<PageTitle>Snake</PageTitle>

<h1>Snake</h1>

<div class="mb-2">
    <strong>Score:</strong> @score
    <span class="ms-3"><strong>Best:</strong> @bestScore</span>
</div>

<div class="board-wrapper">
    <div class="board-container">
        <div @ref="boardRef"
             tabindex="0"
             class="board"
             @onkeydown="OnKeyDown"
             @onkeydown:preventDefault
             style="grid-template-columns: repeat(@Cols, @CellPx); grid-template-rows: repeat(@Rows, @CellPx);">
            @for (var r = 0; r < Rows; r++)
            {
                for (var c = 0; c < Cols; c++)
                {
                    var isFood = food.R == r && food.C == c;
                    var isSnake = snake.Any(p => p.R == r && p.C == c);
                    var css = isFood ? "cell food" : isSnake ? "cell snake" : "cell";
                    <div class="@css"></div>
                }
            }
        </div>

        @if (!hasStarted)
        {
            <div class="overlay">
                <div class="overlay-panel">
                    <div class="overlay-title">Snake</div>
                    <button class="btn btn-primary" @onclick="Play">Play</button>
                </div>
            </div>
        }
        @if (isGameOver)
        {
            <div class="overlay">
                <div class="overlay-panel">
                    <div class="overlay-title text-danger">Game Over</div>
                    <button class="btn btn-primary" @onclick="Play">Play</button>
                </div>
            </div>
        }
    </div>
</div>

@code {
    private const int Rows = 20;
    private const int Cols = 20;
    private const string CellPx = "22px"; // cell size (including gap visually)

    private enum Direction { Up, Down, Left, Right }

    private readonly record struct Pos(int R, int C);

    private List<Pos> snake = new();
    private Pos food;
    private Direction direction = Direction.Right;
    private Direction pendingDirection = Direction.Right;
    private System.Timers.Timer? loopTimer;
    private bool isGameOver = false;
    private bool hasStarted = false;
    private int score = 0;
    private int bestScore = 0;
    private readonly Random rng = new();
    private ElementReference boardRef;

    protected override void OnInitialized()
    {
        SetupNewGame();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await boardRef.FocusAsync();
        }
    }

    private void SetupNewGame()
    {
        isGameOver = false;
        score = 0;
        direction = Direction.Right;
        pendingDirection = Direction.Right;

        // Start with a 3-length snake near the center moving right
        snake.Clear();
        var startR = Rows / 2;
        var startC = Cols / 2 - 1;
        snake.Add(new Pos(startR, startC - 1));
        snake.Add(new Pos(startR, startC));
        snake.Add(new Pos(startR, startC + 1));

        PlaceFood();
        StopTimer();
    }

    private async Task StartGame()
    {
        if (isGameOver)
        {
            SetupNewGame();
        }

        if (loopTimer is null)
        {
            loopTimer = new System.Timers.Timer(120);
            loopTimer.Elapsed += (_, __) => Tick();
            loopTimer.AutoReset = true;
        }

        loopTimer.Start();
        await InvokeAsync(StateHasChanged);
        // Ensure the board has focus so keyboard controls work immediately after Start
        await boardRef.FocusAsync();
    }

    private async Task Play()
    {
        hasStarted = true;
        await StartGame();
    }

    private void StopTimer()
    {
        loopTimer?.Stop();
    }

    private void Tick()
    {
        direction = pendingDirection; // apply latest allowed turn once per tick

        var head = snake[^1];
        var next = direction switch
        {
            Direction.Up => new Pos(head.R - 1, head.C),
            Direction.Down => new Pos(head.R + 1, head.C),
            Direction.Left => new Pos(head.R, head.C - 1),
            Direction.Right => new Pos(head.R, head.C + 1),
            _ => head
        };

        // collision with walls
        if (next.R < 0 || next.R >= Rows || next.C < 0 || next.C >= Cols)
        {
            GameOver();
            return;
        }

        // collision with self
        if (snake.Any(p => p.R == next.R && p.C == next.C))
        {
            GameOver();
            return;
        }

        var ate = (next.R == food.R && next.C == food.C);
        snake.Add(next);
        if (ate)
        {
            score += 1;
            if (score > bestScore) bestScore = score;
            PlaceFood();
        }
        else
        {
            // move forward by removing tail
            snake.RemoveAt(0);
        }

        InvokeAsync(StateHasChanged);
    }

    private void GameOver()
    {
        isGameOver = true;
        StopTimer();
        InvokeAsync(StateHasChanged);
    }

    private void PlaceFood()
    {
        // find a random empty cell
        while (true)
        {
            var r = rng.Next(Rows);
            var c = rng.Next(Cols);
            if (!snake.Any(p => p.R == r && p.C == c))
            {
                food = new Pos(r, c);
                return;
            }
        }
    }

    private static bool IsOpposite(Direction a, Direction b) =>
        (a == Direction.Up && b == Direction.Down) ||
        (a == Direction.Down && b == Direction.Up) ||
        (a == Direction.Left && b == Direction.Right) ||
        (a == Direction.Right && b == Direction.Left);

    private void OnKeyDown(KeyboardEventArgs e)
    {
        var key = e.Key;
        Direction? desired = key switch
        {
            "ArrowUp" or "w" or "W" => Direction.Up,
            "ArrowDown" or "s" or "S" => Direction.Down,
            "ArrowLeft" or "a" or "A" => Direction.Left,
            "ArrowRight" or "d" or "D" => Direction.Right,
            _ => null
        };

        if (desired is Direction d && !IsOpposite(d, direction))
        {
            pendingDirection = d;
        }
    }

    // Ensure timer is disposed when component is removed
    public void Dispose()
    {
        if (loopTimer is not null)
        {
            loopTimer.Stop();
            loopTimer.Dispose();
        }
    }
}
