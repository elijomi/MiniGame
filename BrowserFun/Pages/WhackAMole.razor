@page "/whack"
@using BrowserFun.Components.Icons

<PageTitle>Whack a Mole</PageTitle>

<div class="wam-wrapper">
    <div class="game-header">
        <h1>Whack a Mole</h1>
        <div class="status-row mb-2">
            <div class="lives" aria-label="Lives">
                @for (var i = 0; i < AllowedMisses; i++)
                {
                    var lost = i >= MissesLeft;
                    <span class="heart @(lost ? "lost" : null)" aria-hidden="true">&#10084;</span>
                }
            </div>
            <div class="level">
                <div class="level-bar" aria-label="Level @Level">
                    <div class="level-fill" style="@(LevelProgressStyle)"></div>
                    <div class="level-label">Level @Level</div>
                </div>
            </div>
        </div>
    </div>

    <div class="wam-container">
        <div class="wam-grid"
             style="grid-template-columns: repeat(@Cols, @CellPx); grid-template-rows: repeat(@Rows, @CellPx);">
            @for (var idx = 0; idx < Rows * Cols; idx++)
            {
                var holeIndex = idx; // capture per-iteration value for event handler
                var isMole = activeMoleIndex == holeIndex;
                var isHit = lastHitIndex == holeIndex;
                var css = $"hole{(isMole ? " mole" : string.Empty)}{(isHit ? " hit" : string.Empty)}";
                <button class="@css" @onclick="(() => Whack(holeIndex))" aria-label="Hole @holeIndex">
                    @if (isMole)
                    {
                        <MoleIcon class="mole-icon" />
                    }
                </button>
            }
        </div>

        @if (!hasStarted)
        {
            <div class="overlay">
                <div class="overlay-panel">
                    <div class="overlay-title">Whack a Mole</div>
                    <button class="btn btn-primary" @onclick="Play">Play</button>
                </div>
            </div>
        }
        @if (isGameOver)
        {
            <div class="overlay">
                <div class="overlay-panel">
                    <div class="overlay-title text-danger">Game Over</div>
                    <div class="mb-2">Level reached: <strong>@Level</strong></div>
                    <button class="btn btn-primary" @onclick="Play">Play</button>
                </div>
            </div>
        }
    </div>
</div>

@code {
    private const int Rows = 3;
    private const int Cols = 3;
    private const string CellPx = "96px"; // hole size

    private int? activeMoleIndex;
    private int hits = 0;
    private int misses = 0;
    private const int AllowedMisses = 10;
    private bool isRunning = false;
    private bool isGameOver = false;
    private bool hasStarted = false;
    private readonly Random rng = new();
    private CancellationTokenSource? cts;

    private void Reset()
    {
        cts?.Cancel();
        cts?.Dispose();
        cts = null;
        isRunning = false;
        isGameOver = false;
        activeMoleIndex = null;
        hits = 0;
        misses = 0;
    }

    private async Task Play()
    {
        hasStarted = true;
        Reset();
        isRunning = true;
        cts = new CancellationTokenSource();
        var token = cts.Token;

        // Start spawn loop only (no countdown timer)
        _ = SpawnLoop(token);
        await InvokeAsync(StateHasChanged);
    }

    private async Task SpawnLoop(CancellationToken token)
    {
        int? lastIdx = null;
        try
        {
            while (!token.IsCancellationRequested)
            {
                // choose a random hole different from last
                int next;
                do { next = rng.Next(Rows * Cols); } while (lastIdx is int li && next == li);
                lastIdx = next;
                activeMoleIndex = next;
                await InvokeAsync(StateHasChanged);

                // Mole visible duration (speeds up as hits increase)
                var visibleMs = GetVisibleDurationMs();
                await Task.Delay(visibleMs, token);

                // Hide mole if still active (count as a miss)
                if (activeMoleIndex == next)
                {
                    misses++;
                    activeMoleIndex = null;
                    await InvokeAsync(StateHasChanged);
                    if (MissesLeft <= 0)
                    {
                        GameOver();
                        return;
                    }
                }

                // Small gap before next mole
                var gapMs = GetGapDurationMs();
                await Task.Delay(gapMs, token);
            }
        }
        catch (TaskCanceledException) { }
    }

    private void Whack(int idx)
    {
        if (!isRunning || isGameOver) return;
        if (activeMoleIndex == idx)
        {
            hits++;
            // mark the hole as hit for a brief visual effect
            lastHitIndex = idx;
            activeMoleIndex = null;
            InvokeAsync(StateHasChanged);
            _ = ClearHitAfterAsync(idx);
        }
    }

    private int? lastHitIndex;

    private async Task ClearHitAfterAsync(int idx)
    {
        try
        {
            await Task.Delay(300);
            if (lastHitIndex == idx)
            {
                lastHitIndex = null;
                await InvokeAsync(StateHasChanged);
            }
        }
        catch { /* ignore */ }
    }

    private int GetVisibleDurationMs()
    {
        // Difficulty increases every HitsPerLevel hits (0-based index)
        var level = Math.Max(0, hits / HitsPerLevel);
        const int baseMin = 650;
        const int baseMax = 1000; // exclusive upper bound semantics of Random.Next
        const int perLevelReduction = 60;
        const int absoluteMin = 250;

        var min = Math.Max(absoluteMin, baseMin - perLevelReduction * level);
        var max = Math.Max(min + 50, baseMax - perLevelReduction * level);
        return rng.Next(min, max);
    }

    private int GetGapDurationMs()
    {
        var level = Math.Max(0, hits / HitsPerLevel);
        const int baseMin = 200;
        const int baseMax = 450; // exclusive upper bound semantics of Random.Next
        const int perLevelReduction = 30;
        const int absoluteMin = 80;

        var min = Math.Max(absoluteMin, baseMin - perLevelReduction * level);
        var max = Math.Max(min + 30, baseMax - perLevelReduction * level);
        return rng.Next(min, max);
    }

    private const int HitsPerLevel = 5;
    private int Level => (hits / HitsPerLevel) + 1;
    private int MissesLeft => Math.Max(0, AllowedMisses - misses);
    private int LevelProgressPercent => Math.Min(100, (hits % HitsPerLevel) * (100 / HitsPerLevel));
    private string LevelProgressStyle => $"width:{LevelProgressPercent}%";

    private void GameOver()
    {
        isRunning = false;
        isGameOver = true;
        cts?.Cancel();
        InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        cts?.Cancel();
        cts?.Dispose();
    }
}
